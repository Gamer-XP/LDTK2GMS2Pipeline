using System.Reflection;
using LDTK2GMS2Pipeline.Wrapper;
using Microsoft.CSharp.RuntimeBinder;
using Microsoft.Extensions.DependencyModel;
using Spectre.Console;

namespace LDTK2GMS2Pipeline.Utilities;

public static class GMAssemblyUtilities
{
    private static List<GMProjectWrapper>? _wrappers;
    
    private static List<GMProjectWrapper> GetWrappers()
    {
        if (_wrappers != null)
            return _wrappers;

        _wrappers = new();
        foreach (Type typeInfo in typeof(GMProjectWrapper).Assembly.GetTypes().Where( t => t.IsClass && !t.IsAbstract && t.IsAssignableTo(typeof(GMProjectWrapper))))
        {
            GMProjectWrapper? wrapper = (GMProjectWrapper?) Activator.CreateInstance(typeInfo);
            if (wrapper != null) 
                _wrappers.Add(wrapper);
        }

        return _wrappers;
    }

    public static T Invoke<T>( Func<GMProjectWrapper, T> _action )
    {
        foreach (GMProjectWrapper wrapper in GetWrappers())
        {
            try
            {
                return _action(wrapper);
            }
            catch (RuntimeBinderException e)
            {
                // No
            }
        }
        
        throw new Exception("No valid wrappers found");
    }
    
    public static async Task InvokeTask( Func<GMProjectWrapper, Task> _action )
    {
        foreach (GMProjectWrapper wrapper in GetWrappers())
        {
            try
            {
                await _action(wrapper);
                return;
            }
            catch (RuntimeBinderException e)
            {
                // No
            }
        }
        
        throw new Exception("No valid wrappers found");
    }
    public static async Task<T> InvokeTaskWithResult<T>( Func<GMProjectWrapper, Task<T>> _action )
    {
        foreach (GMProjectWrapper wrapper in GetWrappers())
        {
            try
            {
                return await _action(wrapper);
            }
            catch (RuntimeBinderException e)
            {
                // No
            }
        }
        
        throw new Exception("No valid wrappers found");
    }
    
    private static string? GetInstallationPath( GMBranch _installation )
    {
        //TODO: Different methods for MACOS and LINUX

        string registryFolder;
        switch (_installation)
        {
            case GMBranch.LTS:
                registryFolder = "GameMakerStudio2-LTS";
                break;
            case GMBranch.Beta:
                registryFolder = "GameMakerStudio2-Beta";
                break;
            default:
                registryFolder = "GameMakerStudio2";
                break;
        }

        var installDir = Microsoft.Win32.Registry.GetValue($"HKEY_CURRENT_USER\\SOFTWARE\\{registryFolder}", "Install_Dir", null) as string;
        return installDir;
    }

    private static string[] gmAssemblies = { "CoreResources", "FileIO", "HtmlAgilityPack", "YYPSerialiser", "YYPSerialiserAutoGenerated" };
    
    public static void LoadAssemblies( GMBranch _branch )
    {
        string basePath = GetInstallationPath(_branch) ?? Directory.GetCurrentDirectory();

        foreach (string asmName in gmAssemblies)
        {
            var path = GetFinalPath(asmName);
            if (File.Exists(path))
                LoadAssembly(path);
        }

        AppDomain.CurrentDomain.AssemblyResolve += delegate(object? _sender, ResolveEventArgs _args)
        {
            try
            {
                return LoadAssembly(GetFinalPath(_args.Name));
            }
            catch (Exception ex)
            {
                AnsiConsole.MarkupLineInterpolated($"[red]{ex.Message}[/]");
                return null;
            }
        };

        string GetFinalPath( string _name )
        {
            string assemblyFile = (_name.Contains(','))
                ? _name.Substring(0, _name.IndexOf(','))
                : _name;

            assemblyFile += ".dll";

            return Path.Combine(basePath, assemblyFile);
        }

        Assembly LoadAssembly( string _assemblyPath )
        {
            if (!File.Exists(_assemblyPath))
                return null;
            
            var res = Assembly.LoadFile(_assemblyPath);

            var context = DependencyContext.Load(res);

            if (context != null)
            {
                foreach (RuntimeLibrary library in context.RuntimeLibraries)
                {
                    try
                    {
                        var path = library.Path ?? GetFinalPath(library.Name);
                        // Try to load each dependency
                        if (File.Exists(path))
                            Assembly.LoadFile(path);
                    }
                    catch
                    {
                        // Handle missing dependencies
                        Console.WriteLine($"Could not load dependency: {library.Name}");
                    }
                }
            }

            // Load the main assembly
            return res;
        }
    }
}